---
title: "Allele Specific Expression Quality Control"
author: "Lachlan Baer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    fig_width: 8
    fig_height: 6
    fig_align: "center"
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  error = FALSE, 
  fig.align = "center"
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

# Setup 

```{r packages}
suppressPackageStartupMessages({
  library(tidyverse)
  library(magrittr)
  library(parallel)
  library(here)
  library(AnnotationHub)
  library(purrr)
  library(scales)
  library(kableExtra)
  library(UpSetR)
  library(SeqArray)
})
```

```{r options}
if (interactive()) setwd(here::here())
theme_set(theme_bw())
cores <- detectCores() - 1
```

```{r}
source(here("R/lbFuncs.R"))
```

## EnsDb

```{r}
ah <- AnnotationHub() %>%
  subset(species == "Danio rerio") %>%
  subset(rdataclass == "EnsDb")
ensDb <- ah[["AH83189"]] ## Ens101
genes <- genes(ensDb)
mcols(genes) <- mcols(genes)[
  c("gene_id", "gene_name", "gene_biotype", "entrezid")
]
exons <- exonsBy(ensDb, by = "gene")
```

An `EnsDb` object for Ensemble release 101 was setup for extracting gene and exon annotation information.

## Metadata

```{r}
metadata <- read_csv(here("files/samples.csv")) %>%
  dplyr::select(-sample) %>%
  dplyr::rename(sample = basename, genotype = Genotype)
metadata %>%
  dplyr::rename(
    Sample = sample, `Fish ID` = fish_id, `Batch Killed` = batch_killed,
    `Genotype 1` = genotype, `Genotype 2` = Genotype_2
  ) %>%
  kable(
    align = "l",
    caption = "Sample metadata"
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

```{r}
fad <- metadata %>%
  dplyr::filter(genotype == "EOfAD-like/+") %>%
  pull(sample)
fai <- metadata %>%
  dplyr::filter(genotype == "fAI-like/+") %>%
  pull(sample)
wt <- metadata %>%
  dplyr::filter(genotype == "WT") %>%
  pull(sample)
drChrs <- seq(1:25)
```

# Quality control

There are a number of important quality control measures that must be taken to ensure reliable data for allele specific expression (ASE) testing. 
The following procedures are based around the guidelines described in [Castel et al. Tools and Best Practices for allelic expression analysis.](https://www.biorxiv.org/content/biorxiv/early/2015/03/05/016097.full.pdf)

## WASP

An important aspect to consider in ASE analysis is the potential for read mapping bias.
For RNA-seq data mapped to a reference genome, reads that carry an alternate allele at positions of variation have at least one mismatch, and therefore a lower probability of aligning correctly than reads containing the reference allele.

`WASP` provides a suite of tools for unbiased allele-specific read mapping.
The `WASP` workflow for mappability filtering is defined by 5 steps:

1. Reads are mapped normally with the user's mapper of choice (`STAR` was chosen in this case).
2. Reads that overlap identified SNVs and therefore may have mapping bias are determined using `find_intersecting_snps.py` script.
Each overlapping read is output as a set of synthetic reads in `FASTQ` format with its allele swapped to to the other allele at the SNV site.
3. The set of allele-swapped reads are re-mapped using the same method and options used in step 1.
4. Reads where one or more allelic versions fail to map back to the same location are removed using `filter_remapped_reads.py` script.
5. Reads that did not overlap SNVs are merged with those that show unbiased mapping from step 4 using `samtools`, resulting in a complete set of mappability-filtered aligned reads in `BAM` format.

To begin the `WASP` fltering procedure, input files containing genetic variants (SNVs) previously identified by the `GATK` workflow are needed.
Since we do not have phasing information, it is recommended to use text-based format opposed to `HDF5` for the input files.
The text-based input files require three space-delimited columns (position, ref_allele, alt_allele), and one input file per chromosome.
The filenames must follow the convention `<chr>.snps.txt.gz` (e.g `1.snps.txt.gz` for chromosome 1).

To gather SNV information called by the `GATK` workflow, the `VCF` files were firstly converted into `GDS` objects.
`GDS` objects allow for easy access of the data in `R`, but are large so were kept on the HPC system.

```{r, results='hide'}
vcfPaths <- list.files(
  "/hpcfs/users/a1647910/210408_psen1_fADfAI_snv/09_callSnvs/selected",
  pattern = ".vcf.gz$",
  full.names = TRUE
)
lapply(vcfPaths, function(vcf){
  gdsPath <- paste0(
    str_remove(dirname(vcf), "selected"),
    "gds/",
    str_remove(basename(vcf), ".vcf.gz"),
    ".gds"
  )
  if (!file.exists(gdsPath)) {
    if (!dir.exists(dirname(gdsPath))) {
      dir.create(dirname(gdsPath), recursive = TRUE)
    }
    seqVCF2GDS(vcf, gdsPath)
  }
})
```

```{r}
gdsPaths <- list.files(
  "/hpcfs/users/a1647910/210408_psen1_fADfAI_snv/09_callSnvs/gds",
  pattern = ".gds$",
  full.names = TRUE
)
```

```{r}
snvList <- lapply(seq_along(gdsPaths), function(x){
  gdsPath <- gdsPaths[x]
  sample <- basename(gdsPath) %>%
    str_remove(".gds")
  gds <- seqOpen(gdsPath, readonly = FALSE)
  snvs <- tibble(
    variant.id = seqGetData(gds, "variant.id"),
    chromosome = seqGetData(gds, "chromosome"),
    position = seqGetData(gds, "position"),
    allele = seqGetData(gds, "allele")
  ) %>%
    dplyr::filter(
      chromosome %in% drChrs,
      str_detect(allele, "\\*", negate = TRUE) ## Remove deletions
    ) %>%
    mutate(
      sample = sample,
      refAllele = str_split(allele, ",", simplify = TRUE)[,1],
      altAllele = str_split(allele, ",", simplify = TRUE)[,2]
    )
  seqClose(gds)
  return(snvs)
})
```

```{r}
filtProgress <- snvList %>%
  bind_rows() %>%
  group_by(sample) %>%
  summarise(noFilt = n())
```

```{r, results='hide'}
lapply(snvList, function(x){
  chrList <- x %>%
    dplyr::select(chromosome, position, refAllele, altAllele, sample) %>%
    split(.[,'chromosome'])
  lapply(chrList, function(x){
    chr <- unique(x$chromosome)
    sample <- unique(x$sample)
    path <- paste0(
      "/hpcfs/users/a1647910/210408_psen1_fADfAI_snv/10_wasp/snvs/",
      sample,
      "/",
      chr,
      ".snps.txt.gz"
    )
    if (!file.exists(path)) {
      if (!dir.exists(dirname(path))) {
        dir.create(dirname(path), recursive = TRUE)
      }
      tibble(
        position = x$position,
        refAllele = x$refAllele,
        altAllele = x$altAllele
      ) %>%
        write_delim(file = path, delim = " ", col_names = FALSE)
    }
  })
})
```

After exporting text-based input files, WASP filtering was performed on the HPC system.
The resulting `BAM` files were ready for allele specific expression read counting.

## ASEReadCounter

`GATK` tool `ASEReadCounter` calculates allele counts at a set of positions after applying filters specifically tuned for ASE analysis of RNA-seq data.
The filters operate on mapping quality, base quality, depth of coverage and overlapping paired reads.
Each of these filters can be controlled by command-line arguments.
The data in this analysis was generated with the following options:

- `--min-mapping-quality 10`
- `--min-base-quality 20`
- `--count-overlap-reads-handling COUNT_FRAGMENTS_REQUIRE_SAME_BASE`
    - Ths option counts all fragments where the base is consistent when mate pairs overlap.
- `--min-depth-of-non-filtered-base -1`
    - This argument is disabled, because depth filtering was performed manually (see next section).

Heterozygous SNVs detected by `ASEReadCounter` were recorded in separate `tsv` files for each sample. 
These were loaded into R as a list of tibbles containing the unprocessed raw data for ASE analysis.

```{r}
files <- list.files(
  "/hpcfs/users/a1647910/210408_psen1_fADfAI_snv/11_aseReadCounter",
  full.names = TRUE
)
samples <- basename(files) %>%
  str_remove(".tsv")
```

```{r}
aseCounts <- lapply(files, function(file){
  sample <- basename(file) %>%
    str_remove(".tsv")
  read_tsv(
    file,
    col_types = "cdcccdddddddd"
  ) %>%
    dplyr::filter(contig %in% as.character(drChrs)) %>%
    mutate(
      sample = sample,
      allele = paste0(refAllele, ",", altAllele)
    ) %>%
    left_join(metadata[,c("sample", "genotype")]) %>%
    dplyr::select(
      chromosome = contig, position, allele, refCount, altCount, totalCount,
      sample, genotype, lowMAPQDepth, lowBaseQDepth, rawDepth, otherBases,
      improperPairs, refAllele, altAllele
    )
}) %>% 
  set_names(samples)
```

```{r include=FALSE, eval=FALSE}
# nucCols <- tibble(A = NA, C = NA, G = NA, T = NA) # In case a base is not detected
# perBaseCounts <- lapply(aseCounts, function(x){
#   x %>%
#     mutate(allele = paste0(refAllele, ",", altAllele)) %>%
#     pivot_longer(
#       cols = c("refAllele", "altAllele"),
#       names_to = "variant",
#       values_to = "base"
#     ) %>% 
#     mutate(value = ifelse(variant == "refAllele", refCount, altCount)) %>%
#     dplyr::select(-variant) %>%
#     pivot_wider(names_from = base, values_from = value) %>%
#     add_column(!!!nucCols[!names(nucCols) %in% names(.)]) %>% # Adds column of NA's if no detected base
#     dplyr::select(
#       chromosome = contig, position, allele, A, C, G, T, totalCount, 
#       rawDepth, sample
#     ) %>%
#     left_join(metadata[,c("sample", "genotype")])
# })
# perBaseProps <- lapply(perBaseCounts, function(x){
#   x %>%
#     mutate(across(c(A, C, G, T), ~ ./totalCount))
# })
```

```{r}
filtProgress <- aseCounts %>%
  bind_rows() %>%
  group_by(sample) %>%
  summarise(
    softwareFilt = n()
  ) %>%
  left_join(filtProgress)
```

The number of genome-wide het-SNV positions as reported by `ASEReadCounter` following `WASP` filtering ranged from `r comma(min(filtProgress$softwareFilt))` to `r comma(max(filtProgress$softwareFilt))` across all samples.

```{r}
aseFiltProps <- aseCounts %>%
  bind_rows() %>%
  group_by(sample) %>%
  summarise(
    mapQ = sum(lowMAPQDepth) / sum(rawDepth),
    baseQ = sum(lowBaseQDepth) / sum(rawDepth),
    otherBases = sum(otherBases) / sum(rawDepth)
  )
```

Across all samples, reads filtered due to insufficient mapping quality ranged between `r percent(min(aseFiltProps$mapQ), accuracy = 0.01)` and `r percent(max(aseFiltProps$mapQ), accuracy = 0.01)`, reads filtered due to base quality ranged between `r percent(min(aseFiltProps$baseQ), accuracy = 0.01)` and `r percent(max(aseFiltProps$baseQ), accuracy = 0.01)`, and reads filtered due to overlapping mate pairs with inconsistent bases ranged between `r percent(min(aseFiltProps$otherBases), accuracy = 0.01)` and `r percent(max(aseFiltProps$otherBases), accuracy = 0.01)`.

## Filtering

The remaining manual filtering procedures were carried out in `R`.

### Exonic variants

Variants in this analysis were determined from RNA-seq data, and therefore were filtered based on genomic position for those that lie in only exonic regions (Ensembl version 101).
Gene identifiers were also annotated for each position to enable downstream analysis of ASE across genes.

```{r}
exonOverlaps <- lapply(aseCounts, function(x){
  indices <- x %>%
    dplyr::select(seqnames = chromosome, start = position) %>%
    mutate(end = start) %>%
    makeGRangesFromDataFrame() %>%
    findOverlaps(exons)
  tibble(
    snvInd = as.data.frame(indices)$queryHits,
    geneInd = as.data.frame(indices)$subjectHits
  )
})
```

```{r}
counts <- lapply(seq_along(aseCounts), function(x){
  aseCounts[[x]][exonOverlaps[[x]]$snvInd,] %>%
    cbind(gene = names(exons[exonOverlaps[[x]]$geneInd])) %>%
    as_tibble() %>%
    rownames_to_column("snvID")
}) %>%
  set_names(samples)
```

```{r}
filtProgress <- counts %>%
  bind_rows() %>%
  group_by(sample) %>%
  summarise(
    exonFilt = n()
  ) %>%
  left_join(filtProgress)
```

After filtering for SNVs in exonic regions, the remaining number of het-SNVs ranged from `r comma(min(filtProgress$exonFilt))` to `r comma(max(filtProgress$exonFilt))` across all samples.

### Coverage 

Another important QC step involves filtering Het-SNV sites based on coverage, as sites with low total counts are uninformative.

Firstly, a quick inspection of coverage distribution:

```{r, fig.cap="*Cumulative distribution of RNA-seq read coverage per het-SNV. Each line represents a separate sample. No samples appear problematic as they all display consistent read coverage distributions.*"}
counts %>%
  bind_rows() %>%
  ggplot(aes(totalCount, colour = sample)) +
  stat_ecdf(geom = "step") +
  coord_cartesian(xlim = c(0, 400)) +
  labs(
    x = "Reads / het-SNV",
    y = "Cumulative distribution",
    caption = ""
  ) +
  theme(legend.position = "none")
```

```{r, fig.cap="*The number of het-SNVs per sample that satisfy read coverage cut-offs*"}
lapply(counts, function(x){
  n0 <- x %>%
    dplyr::filter(totalCount >= 0) %>%
    nrow()
  n10 <- x %>%
    dplyr::filter(totalCount >= 10) %>%
    nrow()
  n20 <- x %>%
    dplyr::filter(totalCount >= 20) %>%
    nrow()
  n30 <- x %>%
    dplyr::filter(totalCount >= 30) %>%
    nrow()
  n60 <- x %>%
    dplyr::filter(totalCount >= 60) %>%
    nrow()
  sample <- unique(x$sample)
  tibble(
    bin = c("\u2265 0", "\u2265 10", "\u2265 20", "\u2265 30", "\u2265 60"),
    n = c(n0, n10, n20, n30, n60),
    sample = sample
  )
}) %>%
  bind_rows() %>%
  ggplot(aes(bin, n, fill = bin)) +
  geom_boxplot() +
  labs(x = "Reads / het-SNV", y = "het-SNVs per sample") +
  theme(legend.position = "none")
```

```{r}
counts <- lapply(counts, function(x){
  dplyr::filter(x, totalCount >= 10)
})
```

```{r}
filtProgress <- counts %>%
  bind_rows() %>%
  group_by(sample) %>%
  summarise(
    covFilt = n()
  ) %>%
  left_join(filtProgress)
```

A cut-off of at least 10 counts per het-SNV position was applied, leaving `r comma(min(filtProgress$covFilt))` to `r comma(max(filtProgress$covFilt))` het-SNVs across all samples.

### Mono-allelic expression

Producing evidence of mono-allelic expression from short read RNA-seq datasets without parental genotypes or imprinting information is a controversial issue.
Het-SNV sites were therefore filtered based on a depth criteria for each allele ($\ge$ 3 counts or $>$ 1% of the total counts for that allele).

```{r}
counts <- lapply(counts, function(x){
  dplyr::filter(
    x,
    refCount >= 3,
    altCount >= 3,
    refCount / totalCount > 0.01,
    altCount / totalCount > 0.01
  )
})
```

```{r}
filtProgress <- counts %>%
  bind_rows() %>%
  group_by(sample) %>%
  summarise(
    monoFilt = n()
  ) %>%
  left_join(filtProgress)
```

After filtering for mono-allelic expression, `r comma(min(filtProgress$monoFilt))` to `r comma(max(filtProgress$monoFilt))` het-SNVs remained across all samples.

# Summary

```{r, fig.cap="*The total number of het-SNVs remaining after various quality control filtering steps. The filters were applied sequentially from left to right across the x-axis, such that the remaining number of het-SNVs was always less than the previous step.*"}
filtProgress %>%
  dplyr::select(
    sample, None = noFilt, `WASP/ASEReadCounter` = softwareFilt,
    Exonic = exonFilt, Coverage = covFilt, `Mono-allelic expression` = monoFilt
  ) %>%
  pivot_longer(cols = -sample, names_to = "Filter", values_to = "SNVs") %>%
  mutate(Filter = factor(Filter, levels = unique(.$Filter))) %>%
  ggplot(aes(Filter, SNVs, group = Filter, fill = Filter)) +
  geom_boxplot() +
  scale_y_log10(
    labels = comma,
    breaks = c(seq(0, 500000, by = 100000), seq(750000, 1500000, by = 250000))
  ) +
  labs(y = "hetSNVs per sample") +
  theme(
    legend.position = "bottom",
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  )
```

```{r}
genesWithSnvs <- lapply(counts, function(x){
  sample <- unique(x$sample)
  atLeast1 <- length(unique(x$gene))
  atLeast2 <- x %>%
    group_by(gene) %>%
    summarise(n = n()) %>%
    dplyr::filter(n >= 2) %>%
    nrow()
  snvs <- nrow(x)
  tibble(sample = sample, atLeast1 = atLeast1, atLeast2 = atLeast2, snvs = snvs)
}) %>%
  bind_rows() %>%
  left_join(metadata[,c("sample", "genotype")]) %>%
  dplyr::arrange(genotype, sample)
```

```{r}
genesWithSnvs %>%
  dplyr::select(
    Sample = sample, Genotype = genotype, Genes = atLeast1, SNVs = snvs
  ) %>%
  kable(
    align = "l",
    caption = paste0(
      "A summary of the remaining number of genes and SNVs detected in each ",
      "sample after all quality control procedures were performed."
    )
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

## Reference mapping bias

`WASP` filtering is expected to remove the vast majority of reads with mapping bias, but was checked to confirm its effectiveness.
To estimate this effect the genome-wide reference allele ratio was calculated, which indicates a residual mapping bias if it shows a large deviation from 0.5.

```{r}
ratios <- lapply(counts, function(x){
  x %>%
    dplyr::filter(totalCount != 0) %>%
    mutate(
      refRatio = refCount / totalCount,
      altRatio = altCount / totalCount
    ) %>%
    dplyr::select(
      chromosome, position, allele, refRatio, altRatio, totalCount,
      sample, genotype, gene
    )
})
```

This can be visualised by plotting the distribution of reference allele ratios of each SNV.
Bins were setup such that each bin represented a range of 0.01.
A skew of towards one side of the distribution indicates mapping bias is still present.

```{r, fig.height=9, fig.cap="*Histogram of global reference allele ratios at each het-SNV faceted by sample. Reference ratios above 0.51 are shown in red and below 0.49 in blue, while balanced expression (0.49-0.51) is coloured grey. All samples showed profiles indicative of no residual mapping bias.*"}
ratioDists <- bind_rows(ratios)
ratioDists %>%
  mutate(
    bin = cut(
      refRatio,
      seq(0, 1, by = 0.01),
      labels = FALSE,
      include.lowest = TRUE
    ),
    fill = case_when(
      bin < 49 ~ "red",
      between(bin, 49, 51) ~ "grey",
      bin > 51 ~ "blue"
    )
  ) %>%
  ggplot(aes(refRatio, fill = fill)) +
  geom_histogram(binwidth = 0.01, boundary = 0) +
  labs(x = "Reference allele ratio", y = "Count") +
  scale_fill_manual(values = c("red", "grey50", "blue")) +
  facet_wrap(~ sample, ncol = 4) +
  theme(legend.position = "none")
```

As an alternative viewpoint, boxplots of reference allele ratios were plotted for each sample.
Median/mean reference allele ratios that deviate substantially from 0.5 indicate a mapping bias.

```{r, fig.cap="*Boxplots showing mapping bias for each sample. The mean reference ratio is indicated with a black diamond. Filtering procedures successfully were confirmed to have removed any potential mapping bias.*"}
ratios %>%
  bind_rows() %>%
  left_join(metadata[,c("sample", "genotype")]) %>%
  dplyr::arrange(genotype, sample) %>%
  mutate(sample = factor(sample, levels = unique(sample))) %>%
  ggplot(aes(sample, refRatio, fill = genotype, colour = genotype)) +
  geom_boxplot() +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 2) +
  geom_hline(yintercept = 0.5, linetype = "dashed", colour = "black") +
  labs(x = "Sample", y = "Reference allele ratio") +
  scale_fill_discrete(name = "Genotype") +
  scale_colour_manual(values = rep("grey50", 3)) +
  scale_y_continuous(breaks = seq(0, 1, 0.2)) +
  guides(colour = FALSE) +
  theme(
    axis.text.x = element_text(angle = -90, vjust = 0.5),
    legend.position = "bottom"
  ) +
  ggtitle(label = "Reference allele ratios after QC measures")
```

```{r}
refBias <- ratios %>%
  bind_rows() %>%
  group_by(sample) %>%
  summarise(mean = mean(refRatio), median = median(refRatio))
altBias <- ratios %>%
  bind_rows() %>%
  group_by(sample) %>%
  summarise(mean = mean(altRatio), median = median(altRatio))
```

No reference mapping bias was evident in any sample.
Mean reference ratios ranged between `r round(min(refBias$mean), 3)` and `r round(max(refBias$mean), 3)`.
Median reference ratios ranged between `r round(min(refBias$median), 3)` and `r round(max(refBias$median), 3)`.

# Export

`geneiASE` software was chosen for static ASE testing.
Static ASE describes the difference between two variants of a heterozygous allele in a single sample in an unchanging condition.
For static ASE, `geneiASE` software requires allele counts as a `tsv` file with four columns: feautureID, snpID, alternative allele count, reference allele count.
Each sample's allele counts were exported following this format for ASE testing with `geneiASE`.

```{r, results="hide"}
staticCounts <- lapply(counts, function(x){
  x %>%
    left_join(altBias[,c("sample", "mean")]) %>%
    dplyr::select(
      gene, snvID, altCount, refCount, betabinom.p = mean
    )
})
lapply(seq_along(staticCounts), function(x){
  path <- paste0(
    "/hpcfs/users/a1647910/210408_psen1_fADfAI_snv/12_geneiase/counts/",
    names(staticCounts[x]),
    ".static.tsv"
  )
  if (!file.exists(path)) {
    if (!dir.exists(dirname(path))) {
      dir.create(dirname(path), recursive = TRUE)
    }
    write_tsv(staticCounts[[x]], path)
  }
})
```

```{r}
sessionInfo()
```

