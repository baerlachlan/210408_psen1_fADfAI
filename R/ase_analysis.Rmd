---
title: "Allele Specific Expression Analysis"
author: "Lachlan Baer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: flatly
    toc: true
    toc_float: true
    toc_depth: 4
    fig_width: 8
    fig_height: 6
    fig_align: "center"
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r knitr, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  error = FALSE, 
  fig.align = "center"
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

# Introduction

The motivation for performing an allele specific expression (ASE) analysis stems from the idea that selecting for a particular chromosome (i.e. the mutant chromosome) within an experimental group also selects for any expression quantitative trait loci (eQTLs) that exist on that chromosome.
Therefore exists the possibility of differences in transcript abundances between groups tested for differential expression due to different sets of allelic expression characteristics and separate from the effect of the mutation.
This would not be a problem in isogenic organisms such as mice, but zebrafish are not isogenic.
If the eQTL idea is true, one would expect to see a number of differentially expressed genes on the same chromosome of the mutation, which is indeed the case in this dataset.
However, if not true, and the observations are caused by the effect of the mutation, an explanation must describe the functional relationship between genes on the same chromosome as the mutation.
One such possibility is that functionally related genes tend to cluster on chromosomes through evolutionary time because it allows for advantageous allelic combinations to remain together due to the suppressed chance for separation through recombination or chromosomal segregation.

The aim of this analysis is to therefore tease apart these two possibilities to the best ability with the available RNA-seq data.
In particular, allele specific expression testing will be used to assess:

1. The potential for ASE to impact differential expression testing in an undesired manner.
2. Whether an overall enrichment of ASE is observed on the chromosome harbouring the mutation(s).

# Setup 

```{r packages}
suppressPackageStartupMessages({
  ## Common
  library(tidyverse)
  library(magrittr)
  library(future.apply)
  library(here)
  library(AnnotationHub)
  library(purrr)
  library(scales)
  library(kableExtra)
  library(tictoc)
  library(ggrepel)
  library(RColorBrewer)
  library(ggpubr)
  library(pander)
  library(rmarkdown)
  ## Project specific
  library(statmod)
  library(fgsea)
  library(VariantAnnotation)
})
```

```{r options}
if (interactive()) setwd(here::here())
theme_set(theme_bw())
cores <- availableCores() - 1
```

```{r}
source("~/bioinformatics/bioToolkit/lbFuncs.R")
```

```{r}
## Choose either remote or local project directory
# projDir <- here()
projDir <- "/hpcfs/users/a1647910/210408_psen1_fADfAI"
```

## EnsDb

An `EnsDb` object was obtained for Ensembl release 101 from which gene and exon information was extracted for annotation required in the analysis.

```{r ensDb}
ah <- AnnotationHub() %>%
  subset(species == "Danio rerio") %>%
  subset(rdataclass == "EnsDb")
ensDb <- ah[["AH83189"]] ## Ens101
genes <- genes(ensDb)
mcols(genes) <- mcols(genes)[
  c("gene_id", "gene_name", "gene_biotype", "entrezid")
]
exons <- exonsBy(ensDb, by = "gene")
drChrs <- seq(1:25)
```

As the chromosomal localisation of genes is of interest, list and dataframe objects containing gene and chromosome information were generated.

```{r c}
chrGenes <- genes %>%
  as_tibble() %>%
  dplyr::filter(seqnames %in% drChrs) %>%
  droplevels() %>%
  split(.$seqnames) %>%
  lapply(pull, gene_id) %>%
  set_names(paste0("chr", names(.)))
```

```{r}
chrGenes_df <- chrGenes %>%
  lapply(list) %>%
  as_tibble() %>%
  pivot_longer(cols = everything(), names_to = "chr", values_to= "feat") %>%
  unnest(feat)
```

## Metadata

```{r metadata}
metadata <- read_csv(file.path(projDir, "files/samples.csv")) %>%
  dplyr::select(-sample) %>%
  dplyr::rename(sample = basename, genotype = Genotype) %>%
  ## We need some sample aliases that follow R naming conventions
  mutate(
    alias = c(
      paste0(rep("fAD", 7), seq(1, 7)),
      paste0(rep("fAI", 8), seq(1, 8)),
      paste0(rep("wt", 9), seq(1, 9))
    )
  )
metadata$genotype <- fct_relevel(
  metadata$genotype,
  c("EOfAD-like/+", "fAI-like/+", "WT")
)
genoCols <- metadata$genotype %>%
  levels() %>%
  length() %>%
  brewer.pal("Set1") %>%
  setNames(levels(metadata$genotype))
compCols <- genoCols[1:2]
```

```{r showMetadata}
metadata %>%
  dplyr::rename(
    Sample = sample, `Fish ID` = fish_id, `Batch Killed` = batch_killed,
    `Genotype 1` = genotype, `Genotype 2` = Genotype_2, Alias = alias
  ) %>%
  kable(
    align = "l",
    caption = "Sample metadata"
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

```{r genotypes}
genotypes <- unique(metadata$genotype) %>%
  as.vector() %>%
  set_names(., .)
fad <- metadata$alias %>%
  str_detect("fAD")
fai <- metadata$alias %>%
  str_detect("fAI")
wt <- metadata$alias %>%
  str_detect("WT")
```

# Allele specific expression

Allele specific expression testing was performed for each sample at the gene-level with `GeneiASE` software.
Genes were classified as showing allele specific expression (ASE) if they had a FDR-adjusted p-value < 0.05.

```{r aseData}
files <- list.files(
  file.path(projDir, "analysis-variants/13_geneiase/2_ase"),
  full.names = TRUE
)
samples <- basename(files) %>%
  str_remove(".static.pval.tsv")
topASE <- lapply(files, function(x){
  sample <- basename(x) %>%
    str_remove(".static.pval.tsv")
  read_tsv(x) %>%
    mutate(
      sig = fdr < 0.05,
      sample = sample
    ) %>%
    left_join(metadata[,c("sample", "alias", "genotype")]) %>%
    dplyr::arrange(fdr) %>%
    mutate(ASE = fdr < 0.05)
}) %>%
  set_names(metadata$alias[match(samples, metadata$sample)]) %>%
  .[metadata$alias]
```

```{r aseCounts}
aseRC <- readRDS(here("files/aseRC.Rds"))
aseRCByGene <- readRDS(here("files/aseRCByGene.Rds")) %>%
  sapply(dplyr::select, gene, everything(), simplify = FALSE)
```

```{r nAse}
nASE <- bind_rows(topASE) %>%
  group_by(alias, sample, genotype) %>%
  summarise(nASE = sum(ASE), total = n()) %>%
  ungroup() %>%
  mutate(
    alias = factor(alias),
    propASE = nASE / total
  )
```

Between `r pander(range(nASE$nASE))` genes were classified as showing ASE across all samples, which accounted for between `r pander(range(percent_format(0.01)(nASE$propASE)))` of the total genes tested.

```{r nAsePlot, fig.height=4, fig.cap="*The number of genes classified as showing significant ASE based on an FDR-adjusted p-value cut-off of 0.05. The number of genes showing ASE was fairly consistent across all samples and genotypes.*"}
nASE %>%
  ggplot(aes(alias, nASE, fill = genotype)) +
  geom_bar(stat = "identity", colour = "black") +
  scale_fill_manual(values = genoCols) +
  scale_y_continuous(breaks = seq(0, 500, 100)) +
  labs(
    x = "Sample",
    y = "Number of ASE genes",
    fill = "Genotype"
  ) +
  theme(
    axis.text.x = element_text(angle = 270, vjust = 0.5, hjust = 0)
  )
```

# ASE overlap with DE genes

Previously analysed different expression testing results were loaded as a list of topTables.

```{r deData}
topDE <- readRDS(file.path(projDir, "files/topTables.Rds")) %>%
  set_names(c("fAD", "fAI"))
```

The `r names(topDE[1])` vs WT comparison showed `r nrow(dplyr::filter(topDE[[1]], DE))` DE genes.

```{r topDEfAD}
topDE[[1]] %>%
  dplyr::filter(DE) %>%
  dplyr::select(geneID = gene_id, symbol = gene_name, chromosome, logFC, logCPM, FDR, bonfP) %>%
  mutate(
    logCPM = formatC(logCPM, digits = 2, format = "f"),
    logFC = formatC(logFC, digits = 2, format = "f"),
    FDR = formatC(FDR, digits = 2, format = "e"),
    bonfP = formatC(bonfP, digits = 2, format = "e"),
  ) %>%
  kable(
    align = "l",
    caption = paste(
      "The", nrow(.), "differentially expressed genes for Alzheimer's genotype",
      "in comparison to wildtype"
    )
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

The `r names(topDE[2])` vs WT comparison showed `r nrow(dplyr::filter(topDE[[2]], DE))` DE genes.

```{r topDEfAI}
topDE[[2]] %>%
  dplyr::filter(DE) %>%
  dplyr::select(geneID = gene_id, symbol = gene_name, chromosome, logFC, logCPM, FDR, bonfP) %>%
  mutate(
    logCPM = formatC(logCPM, digits = 2, format = "f"),
    logFC = formatC(logFC, digits = 2, format = "f"),
    FDR = formatC(FDR, digits = 2, format = "e"),
    bonfP = formatC(bonfP, digits = 2, format = "e"),
  ) %>%
  kable(
    align = "l",
    caption = paste(
      "The", nrow(.), "differentially expressed genes for Acne Inversa genotype",
      "in comparison to wildtype"
    )
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

For each significant differentially expressed gene, ASE results were assessed across each sample.
Each sample contained a different subset of genes available for ASE testing due to conditions that must be met when preparing the data.
This means that in some samples information about a gene of interest may not be available.
For a gene to reach the ASE testing stage, it must satisfy each of the following criteria sequentially:

1. Have genotypes called within exons by the `GATK` RNA-seq short variant discovery workflow
2. Pass specific hard filters recommended by the `GATK` for RNA-seq data
3. Contain at least 1 heterozygous SNV
4. Pass QC measures for ASE testing

Detailed information about the workflow's QC implementation can be found in the [ASE QC document](ase_qc.html).

```{r deGenes}
deGenes <- sapply(topDE, dplyr::filter, DE, simplify = FALSE)
```

## Genotypes called

```{r}
vcf_file <- file.path(
  "/hpcfs/users/a1647910/210408_psen1_fADfAI",
  "analysis-variants/10_variants/4_extract/all_samples.vcf.gz"
)
svp <- ScanVcfParam(info = "", geno = c("GT", "GQ"))
vcf <- suppressWarnings({
  readVcf(vcf_file, param = svp)
})
samples <- samples(header(vcf))
```

```{r}
gr <- rowRanges(vcf)[,c("REF", "ALT")]
gr$REF <- as.character(gr$REF)
gr$ALT <- CharacterList(gr$ALT) %>%
  unstrsplit(sep = ",")
```

```{r}
sapply(samples, function(sample){
  gr$GT <- geno(vcf)$GT[,sample] %>%
    str_replace(., "\\|", "\\/")  # Not concerned with phasing atm
  gr$GQ <- geno(vcf)$GQ[,sample]
  gr <- gr %>%
    plyranges::filter(!is.na(GQ))  # Remove positions with no genotype call
  genome(gr) <- genome(exons)  # Ensure same genome to allow findOverlaps()
  ## Annotate variants with genes
  hits <- findOverlaps(gr, exons)
  gr$gene_id <- names(exons[subjectHits(hits)])
  gr
}, simplify = FALSE)
```

```{r}
overlaps <- findOverlaps(gr, tmp, ignore.strand=TRUE)
```

```{r deAseOverlap}
deAseOverlap <- sapply(deGenes, function(x){
  lapply(topASE, function(y){
    dplyr::select(x, feat = gene_id, symbol = gene_name, chromosome) %>%
      left_join(y[,c("feat", "sample", "genotype", "ASE")])
  }) %>%
    bind_rows() %>%
    group_by(feat, ASE) %>%
    tally() %>%
    ungroup() %>%
    pivot_wider(names_from = ASE, values_from = n, values_fill = 0) %>%
    dplyr::select(gene = feat, ASE = `TRUE`, no_ASE = `FALSE`, not_tested = `NA`)
}, simplify = FALSE)
```

**Alzheimer's DE genes:**

```{r overlapfAD}
deAseOverlap$fAD %>%
  kable(
    align = "l",
    caption = paste(
      "The number of samples that were tested and showed ASE, tested and did",
      "not show ASE, or not tested at all for each differentially expressed",
      "gene in the Alzheimer's vs wildtype comparison"
    )
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

**Acne Inversa DE genes:**

```{r overlapfAI}
deAseOverlap$fAI %>%
  kable(
    align = "l",
    caption = paste(
      "The number of samples that were tested and showed ASE, tested and did",
      "not show ASE, or not tested at all for each differentially expressed",
      "gene in the Acne Inversa vs wildtype comparison"
    )
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

Unfortunately due to the large amounts of samples that could not be examined for overlap of DE and ASE data, no conclusions could be made regarding the ability for ASE to affect DE results.

# Enrichment testing

While no conclusions were achieved to address the potential for ASE to impact differential expression testing in an undesired manner, more general patterns of ASE were assessed through enrichment testing.
Two different methods were set up to analyse if ASE is enriched on the chromosome that was selected for:

- Fisher's exact test
- Gene set enrichment analysis (GSEA)

## Fisher's exact test

For each chromosome within each sample, the entire set of detected genes tested for ASE were classified by belonging to the chromosome and showing ASE.

```{r fisherTest}
fisherRes <- bind_rows(topASE) %>%
  left_join(chrGenes_df) %>%
  group_by(sample, chr) %>%
  summarise(ase_chr = sum(ASE), noAse_chr = sum(!ASE)) %>%
  group_by(sample) %>%
  mutate(
    ase_notChr = sum(ase_chr) - ase_chr,
    noAse_notChr = sum(noAse_chr) - noAse_chr
  ) %>%
  ungroup() %>%
  left_join(metadata[,c("sample", "genotype")]) %>%
  mutate(
    fisherTest = pmap(
      ## Setup list input to pmap in order that will construct a correct matrix
      list(ase_chr, ase_notChr, noAse_chr, noAse_notChr),
      ~ fisher.test(matrix(c(..1, ..2, ..3, ..4), ncol = 2))
    ),
    fisher.p = vapply(
      fisherTest,
      function(x){x$p.value},
      numeric(1)
    ),
    fdr.p = p.adjust(fisher.p, method = "fdr"),
    bonf.p = p.adjust(fisher.p, method = "bonf"),
    sample = factor(sample, levels = metadata$sample),
    chr = factor(chr, levels = str_sort(unique(chr), numeric = TRUE)),
    sigLabel = ifelse(fdr.p < 0.05, "*", "")
  )
```

This was represented as a 2x2 contingency table for enrichment testing using Fisher's exact test.
An example of a contingency table for chromosome 17 of sample 7_KB_B12 (EOfAD-like/+ genotype) is shown below:

<center>
```{r contTable}
dplyr::filter(fisherRes, sample == "7_KB_B12" & chr == "chr17") %>%
  with(
    matrix(c(ase_chr, ase_notChr, noAse_chr, noAse_notChr), ncol = 2)
  ) %>%
  set_rownames(c("Chr 17", "Not Chr 17")) %>%
  set_colnames(c("ASE", "No ASE")) %>%
  pander()
```
</center>

```{r fisherTestPlot, fig.height=7.5, fig.cap="*Results from Fisher's exact test for enrichment of ASE genes by chromosome. The -log10(p-value) is show for each sample, which are coloured by genotype. Each chromosome is faceted for simpler viewing. The dotted line represents a p-value of 0.05. Samples satisfying a FDR-adjusted p-value of 0.05 show an asterix above the bar.*"}
fisherRes %>%
  ggplot(aes(sample, -log10(fisher.p), fill = genotype)) +
  geom_bar(stat = "identity", position = "dodge", colour= "black", width = 0.7) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  geom_text(aes(label = sigLabel)) +
  scale_fill_manual(values = genoCols) +
  coord_cartesian(ylim = c(NA, max(-log10(fisherRes$fisher.p)) + 0.5)) +
  labs(
    title = "Chromosomal enrichment of genes showing ASE",
    x = "Sample",
    y = log10plab,
    fill = "Genotype") +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "bottom"
  ) +
  facet_wrap(~chr)
```

## Gene Set Enrichment Analysis

As an alternative approach, GSEA was performed using gene sets defined based on the chromosome each gene is located.

The first step for performing GSEA involved creating a ranked list.
The methodology that `GeneiASE` uses for calculating p-values posed two issues when constructing a ranked list:

1. Some p-values were 0
- this causes issues when using -log10(p) as a stat for ranking the genes
2. Sets of genes had equal p-values
- this causes problems the ordering of these genes is arbitrary

```{r}
wilsonConf <- function(p.vals, conf.level = 0.95){
  p <- mean(p.vals)
  n <- length(p.vals)
  alpha <- (1 - conf.level)
  alpha2 <- alpha / 2
  z <- qnorm(1 - alpha2)
  z2 <- z * z
  p1 <- p + 0.5 * z2/n
  p2 <- z * sqrt((p * (1 - p) + 0.25 * z2/n)/n)
  p3 <- 1 + z2/n
  lcl <- (p1 - p2)/p3
  ucl <- (p1 + p2)/p3
  res.wilson <- tibble(
    mean.p = p,
    lower = lcl,
    upper = ucl,
    n = n,
    sig = mean.p < alpha
  )
  return(res.wilson)
}
```

```{r}
bonfConf <- function(adj.p.val, n, n.bonf, conf.level = 0.95, limit = c("lower", "upper")){
  alpha <- ((1 - conf.level) / n.bonf)
  alpha2 <- alpha / 2
  z <- qnorm(1 - alpha2)
  z2 <- z * z
  p1 <- adj.p.val + 0.5 * z2/n
  p2 <- z * sqrt((adj.p.val * (1 - adj.p.val) + 0.25 * z2/n)/n)
  p3 <- 1 + z2/n
  lcl <- (p1 - p2)/p3
  ucl <- (p1 + p2)/p3
  if (limit == "lower"){return(lcl)}
  if (limit == "upper"){return(ucl)}
}
```

```{r insize, include=FALSE, eval=FALSE}
intSizeByN <- lapply(seq(1:1000), function(n){
  p <- 0.05
  alpha <- 1 - p
  alpha2 <- 0.5 * alpha
  z <- qnorm(1 - alpha2)
  z2 <- z * z
  p1 <- p + 0.5 * z2/n
  p2 <- z * sqrt((p * (1 - p) + 0.25 * z2/n)/n)
  p3 <- 1 + z2/n
  lcl <- (p1 - p2)/p3
  ucl <- (p1 + p2)/p3
  res.wilson <- tibble(
    p = p,
    n = n,
    lower = lcl,
    upper = ucl
  )
  return(res.wilson)
})
intSizeByN %>%
  bind_rows() %>%
  mutate(size = upper - lower) %>%
  ggplot(aes(n, size)) +
  geom_line() +
  labs(y = "Wilson interval size") +
  scale_y_continuous(breaks = seq(0, 0.03, by = 0.001)) +
  scale_x_continuous(breaks = seq(0, 1000, by = 100))
```

```{r}
permRanks <- function(topASE){
  topASE[,c("feat", "fdr")] %>%
    mutate(
      fdr = ifelse(fdr == 0, 0.000001, fdr),
      stat = -log10(fdr)
    ) %>%
    split(f = .$stat) %>%
    lapply(function(x){
      pull(x, feat) %>%
        sample(length(.), replace = FALSE)
    }) %>%
    unlist(use.names = FALSE) %>%
    enframe(name = NULL, value = "geneid") %>%
    mutate(stat = seq(1:nrow(.))) %>%
    with(structure(stat, names = geneid)) %>%
    rev()
}
```

```{r}
perms <- 500
fgseaFile <- paste0(
  here(),
  "/files/fgsea_",
  perms,
  "perms.Rds"
)
```

```{r}
## This code chunk has a lengthy run-time and will not run if the object has already been saved
## Due to its large size the object remains on the HPC system
## Across 6 threads it takes 1-2 hours to complete
if (!file.exists(fgseaFile)) {
  plan(list(tweak(multisession, workers = cores), sequential))
  ranks <- future_sapply(1:perms, function(...){
    future_sapply(topASE, permRanks, future.seed = 17)
  }, future.seed = 17) %>%
    t() %>%
    as_tibble()
  fgsea <- future_lapply(as.list(ranks), function(x){
    future_lapply(x, function(y){
      fgseaMultilevel(chrGenes, y, scoreType = "pos", eps = 0)
    }, future.seed = 17)
  }, future.seed = 17) %>%
    set_names(colnames(ranks))
  saveRDS(fgsea, fgseaFile)
  plan(sequential)
}
```

```{r}
fgsea <- readRDS(fgseaFile)
```

```{r}
pvals <- lapply(fgsea, function(x){
  lapply(seq_along(x), function(y){
    x[[y]][,c("pathway", "padj")] %>%
      dplyr::rename(!!as.character(y) := padj)
  }) %>%
    purrr::reduce(left_join) %>%
    column_to_rownames("pathway") %>%
    t() %>%
    as_tibble()
})
```

```{r}
mean <- lapply(pvals, function(sample){
  chrList <- as.list(sample)
  lapply(seq_along(chrList), function(x){
    chr <- names(chrList)[x]
    wilsonConf(chrList[[x]]) %>%
      mutate(chromosome = as.factor(chr))
  }) %>%
    bind_rows() %>%
    dplyr::select(chromosome, everything()) %>%
    mutate(
      adj.mean.p = p.adjust(mean.p, method = "bonf"),
      adj.lower = bonfConf(adj.mean.p, n, length(adj.mean.p), limit = "lower"),
      adj.upper = bonfConf(adj.mean.p, n, length(adj.mean.p), limit = "upper")
    )
}) 
```

```{r}
meanRes <- lapply(seq_along(mean), function(ind){
  x <- mean[[ind]]
  x %>%
    mutate(
      sample = names(mean)[ind],
      chromosome = fct_relevel(chromosome, str_sort(chromosome, numeric = TRUE)),
      sigLabel = ifelse(adj.lower < 0.05, "*", "")
    )
}) %>%
  bind_rows() %>%
  left_join(metadata[,c("alias", "genotype")], by = c("sample" = "alias")) 
```

```{r, fig.height=7.5}
meanRes %>%
  ggplot(aes(sample, -log10(mean.p), fill = genotype)) +
  geom_bar(stat = "identity", position = "dodge", colour = "black", width = 0.7) +
  geom_errorbar(aes(
    ymax = -log10(lower),
    ymin = -log10(upper)
  ), width = 0.2) +
  geom_text(
    aes(label = sigLabel),
    nudge_y = -log10(meanRes$lower) - -log10(meanRes$mean.p) + 0.1
  ) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  facet_wrap(~ chromosome) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    legend.position = "bottom"
  ) +
  scale_fill_manual(values = genoCols) +
  labs(y = log10plab)
```

## Genotype level GSEA

```{r}
topASE_geno <- bind_rows(topASE) %>%
  group_by(feat, genotype) %>%
  summarise(median.p = median(p.nom), .groups = "drop") %>%
  dplyr::arrange(median.p) %>%
  split(f = .$genotype)
```

```{r}
permRanks_geno <- function(x){
  x[,c("feat", "median.p")] %>%
    mutate(
      median.p = ifelse(median.p == 0, 0.000001, median.p),
      stat = -log10(median.p)
    ) %>%
    split(f = .$stat) %>%
    lapply(function(x){
      pull(x, feat) %>%
        sample(length(.), replace = FALSE)
    }) %>%
    unlist(use.names = FALSE) %>%
    enframe(name = NULL, value = "geneid") %>%
    mutate(stat = seq(1:nrow(.))) %>%
    with(structure(stat, names = geneid)) %>%
    rev()
}
```

```{r}
perms <- 500
fgseaFile_geno <- paste0(
  here(),
  "/files/fgsea_geno_",
  perms,
  "perms.Rds"
)
```

```{r}
## This code chunk has a lengthy run-time and will not run if the object has already been saved
## Due to its large size the object remains on the HPC system
## Across 6 threads it takes 1-2 hours to complete
if (!file.exists(fgseaFile_geno)) {
  plan(list(tweak(multisession, workers = cores), sequential))
  ranks <- future_sapply(1:perms, function(...){
    future_sapply(topASE_geno, permRanks_geno, future.seed = 17)
  }, future.seed = 17) %>%
    t() %>%
    as_tibble()
  fgsea <- future_lapply(as.list(ranks), function(x){
    future_lapply(x, function(y){
      fgseaMultilevel(chrGenes, y, scoreType = "pos", eps = 0)
    }, future.seed = 17)
  }, future.seed = 17) %>%
    set_names(colnames(ranks))
  saveRDS(fgsea, fgseaFile_geno)
  plan(sequential)
}
```

```{r}
fgsea_geno <- readRDS(fgseaFile_geno)
```

```{r}
pvals_geno <- lapply(fgsea_geno, function(x){
  lapply(seq_along(x), function(y){
    x[[y]][,c("pathway", "padj")] %>%
      dplyr::rename(!!as.character(y) := padj)
  }) %>%
    purrr::reduce(left_join) %>%
    column_to_rownames("pathway") %>%
    t() %>%
    as_tibble()
})
```

```{r}
mean_geno <- lapply(pvals_geno, function(sample){
  chrList <- as.list(sample)
  lapply(seq_along(chrList), function(x){
    chr <- names(chrList)[x]
    wilsonConf(chrList[[x]]) %>%
      mutate(chromosome = as.factor(chr))
  }) %>%
    bind_rows() %>%
    dplyr::select(chromosome, everything()) %>%
    mutate(
      adj.mean.p = p.adjust(mean.p, method = "bonf"),
      adj.lower = bonfConf(adj.mean.p, n, length(adj.mean.p), limit = "lower"),
      adj.upper = bonfConf(adj.mean.p, n, length(adj.mean.p), limit = "upper")
    )
}) 
```

```{r}
meanRes_geno <- lapply(seq_along(mean_geno), function(ind){
  x <- mean_geno[[ind]]
  x %>%
    mutate(
      genotype = names(mean_geno)[ind],
      chromosome = fct_relevel(chromosome, str_sort(chromosome, numeric = TRUE)),
      sigLabel = ifelse(adj.lower < 0.05, "*", "")
    )
}) %>%
  bind_rows()
```

```{r, fig.height=7.5}
meanRes_geno %>%
  ggplot(aes(genotype, -log10(mean.p), fill = genotype)) +
  geom_bar(stat = "identity", position = "dodge", colour = "black") +
  geom_errorbar(aes(
    ymax = -log10(lower),
    ymin = -log10(upper)
  ), width = 0.2) +
  geom_text(
    aes(label = sigLabel),
    nudge_y = -log10(meanRes$lower) - -log10(meanRes$mean.p) + 0.1
  ) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
  facet_wrap(~ chromosome) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    legend.position = "bottom"
  ) +
  scale_fill_manual(values = genoCols) +
  labs(y = log10plab)
```