---
title: "Differential Expression Enrichment Analysis"
author: "Lachlan Baer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    fig_width: 8
    fig_height: 6
    fig_align: "center"
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  error = FALSE, 
  fig.align = "center"
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

# Setup 

```{r packages}
suppressPackageStartupMessages({
  ## Common
  library(tidyverse)
  library(magrittr)
  library(future.apply)
  library(here)
  library(AnnotationHub)
  library(purrr)
  library(scales)
  library(kableExtra)
  library(tictoc)
  library(ggrepel)
  library(RColorBrewer)
  library(ggpubr)
  library(pander)
  library(rmarkdown)
  ## Project specific
  library(edgeR)
  library(fgsea)
  library(pheatmap)
  library(cqn)
  library(DT)
  library(htmltools)
  library(msigdbr)
})
```

```{r options}
if (interactive()) setwd(here::here())
theme_set(theme_bw())
cores <- availableCores() - 1
```

```{r}
source("~/bioinformatics/bioToolkit/lbFuncs.R")
```

## Annotations

```{r}
ah <- AnnotationHub() %>%
  subset(species == "Danio rerio") %>%
  subset(rdataclass == "EnsDb")
ensDb <- ah[["AH83189"]] ## Ens101
```

```{r}
transcripts <- transcripts(ensDb)
txLen <- exonsBy(ensDb, "tx") %>%
  width() %>%
  vapply(sum, integer(1))
mcols(transcripts) <- mcols(transcripts)[
  c("tx_id", "gene_id", "gc_content")
] %>%
  as.data.frame() %>%
  mutate(length = txLen)
```

```{r}
geneGc <- transcripts %>%
  mcols() %>%
  as_tibble() %>%
  group_by(gene_id) %>%
  summarise(
    gc_content = sum(gc_content*length) / sum(length),
    length = ceiling(median(length))
  )
```

```{r}
genes <- genes(ensDb)
mcols(genes) <- mcols(genes)[
  c("gene_id", "gene_name", "gene_biotype", "entrezid")
] %>%
  as.data.frame() %>%
  left_join(geneGc)
```

An `EnsDb` object was obtained for Ensembl release 101 with the `AnnotationHub` package.
This contained the information required to set up gene and transcript annotations.
Gene-level estimates of GC content and length were also generated which may be required as covariates in suitable analyses.

```{r}
entrezGenes <- genes %>%
  as.data.frame() %>%
  dplyr::filter(!is.na(entrezid)) %>%
  unnest(entrezid) %>%
  dplyr::rename(entrez_gene = entrezid)
```

```{r}
geneChrs <- as.data.frame(genes) %>%
  dplyr::select(gene_id, chromosome = seqnames) %>%
  as_tibble()
```

## Differential expression data

```{r}
metadata <- read_csv(here("files/samples.csv")) %>%
  dplyr::select(-sample) %>%
  dplyr::rename(sample = basename, genotype = Genotype) %>%
  ## We need some sample aliases that follow R naming conventions
  mutate(
    alias = c(
      paste0(rep("fAD", 7), seq(1, 7)),
      paste0(rep("fAI", 8), seq(1, 8)),
      paste0(rep("wt", 9), seq(1, 9))
    ),
    group = genotype
  )
metadata$genotype <- fct_relevel(
  metadata$genotype,
  c("WT", "EOfAD-like/+", "fAI-like/+")
)
genoCols <- metadata$genotype %>%
  levels() %>%
  length() %>%
  brewer.pal("Set1") %>%
  setNames(levels(metadata$genotype))
```

```{r}
topTables <- readRDS(here("files/topTables_cqn.Rds")) %>%
  set_names(c("EOfAD", "fAI"))
```

Genes from both genotype comparisons in the [previous DE analysis](`r here("docs/de_analysis.html")`) were loaded as a list of `topTable` objects.
The names of the list elements were changed from those used in the previous DE analysis, such that they now follow `R` naming conventions and hence allow for more intuitive code.

Only small sets of DE genes were identified due to the presence of an EOfAD-like or fAI-like mutation, which showed `r nrow(dplyr::filter(topTables$EOfAD, DE))` and `r nrow(dplyr::filter(topTables$fAI, DE))` DE genes respectively.

# Enrichment testing

Small numbers of DE genes present challenges as they don't often reach the required statistical power for enrichment methods that use only discrete sets of genes classified as DE.
However, there are other alternative methods that utilise the complete set of detectable genes in the form of a ranked list.

## Ranks

Two approaches were considered for forming a ranked list of genes.
The first involved taking each gene's sign of logFC and multiplying by its corresponding -log10(p-value) of differential expression.
This results in a directional ranking structure moving from most significant upregulated genes to most significant downregulated genes.

```{r}
ranks_d <- lapply(topTables, function(x){
  x %>%
    mutate(stat = -log10(PValue) * sign(logFC)) %>%
    dplyr::arrange(desc(stat)) %>%
    with(structure(stat, names = gene_id))
})
```

An alternative approach is to rank genes only by -log10(p-value), resulting in a list ranked by significance alone with no directionality.
Overall functional effects on a cell are not always consistent with the direction of transcriptional regulation.
i.e. downregulation of one transcript may have a similar resulting function to upregulation of a different transcript.
Therefore, it is important to consider both approaches to gene list ranking structure.

```{r}
ranks_nd <- lapply(topTables, function(x){
  x %>%
    mutate(stat = -log10(PValue)) %>%
    dplyr::arrange(desc(stat)) %>%
    with(structure(stat, names = gene_id))
})
```

## Gene sets

Multiple gene set databases were accessed with the `msigdbr` package.
For this analysis the Hallmark, KEGG, Wikipathways, GO and chromosomal based gene sets were chosen.

```{r}
hm <- msigdbr("Danio rerio", category = "H") %>% 
  left_join(entrezGenes) %>%
  dplyr::filter(!is.na(gene_id)) %>%
  distinct(gs_name, gene_id, .keep_all = TRUE)
hmByGene <- hm %>%
  split(f = .$gene_id) %>%
  lapply(extract2, "gs_name")
hmByID <- hm %>%
  split(f = .$gs_name) %>%
  lapply(extract2, "gene_id")
```

- The Hallmark gene sets consists of `r length(hmByID)` gene sets ranging from sizes of `r min(sapply(hmByID, length))` to `r max(sapply(hmByID, length))` genes.

```{r}
kg <- msigdbr("Danio rerio", category = "C2", subcategory = "CP:KEGG") %>% 
  left_join(entrezGenes) %>%
  dplyr::filter(!is.na(gene_id)) %>%
  distinct(gs_name, gene_id, .keep_all = TRUE)
kgByGene <- kg %>%
  split(f = .$gene_id) %>%
  lapply(extract2, "gs_name")
kgByID <- kg %>%
  split(f = .$gs_name) %>%
  lapply(extract2, "gene_id")
```

- The KEGG gene sets consists of `r length(kgByID)` gene sets ranging from sizes of `r min(sapply(kgByID, length))` to `r max(sapply(kgByID, length))` genes.

```{r}
wk <- msigdbr("Danio rerio", category = "C2", subcategory = "CP:WIKIPATHWAYS") %>% 
  left_join(entrezGenes) %>%
  dplyr::filter(!is.na(gene_id)) %>%
  distinct(gs_name, gene_id, .keep_all = TRUE)
wkByGene <- wk %>%
  split(f = .$gene_id) %>%
  lapply(extract2, "gs_name")
wkByID <- wk %>%
  split(f = .$gs_name) %>%
  lapply(extract2, "gene_id")
```

- The Wikipathways gene sets consists of `r length(wkByID)` gene sets ranging from sizes of `r min(sapply(wkByID, length))` to `r max(sapply(wkByID, length))` genes.

```{r}
chr <- as_tibble(genes)
chrByGene <- chr %>%
  split(f = .$gene_id) %>%
  lapply(extract2, "seqnames")
chrByID <- chr %>%
  dplyr::filter(seqnames %in% seq(1:25)) %>%
  droplevels() %>%
  split(f = .$seqnames) %>%
  lapply(extract2, "gene_id")
```

- The chromosomal gene sets consists of `r length(chrByID)` gene sets (chromosomes) ranging from sizes of `r min(sapply(chrByID, length))` to `r max(sapply(chrByID, length))` genes.

```{r}
goSummaries <- url("https://uofabioinformaticshub.github.io/summaries2GO/data/goSummaries.RDS") %>%
  readRDS() %>%
  mutate(
    Term = Term(id),
    gs_name = Term %>% str_to_upper() %>% str_replace_all("[ -]", "_"),
    gs_name = paste0("GO", ontology, "_", gs_name)
  )
minPath <- 3
go <- msigdbr("Danio rerio", category = "C5") %>% 
  left_join(entrezGenes) %>%
  dplyr::filter(!is.na(gene_id)) %>%
  left_join(goSummaries) %>% 
  dplyr::filter(shortest_path >= minPath) %>%
  distinct(gs_name, gene_id, .keep_all = TRUE)
goByGene <- go %>%
  split(f = .$gene_id) %>%
  lapply(extract2, "gs_name")
goByID <- go %>%
  split(f = .$gs_name) %>%
  lapply(extract2, "gene_id")
```

- The GO gene sets consists of `r length(goByID)` gene sets ranging from sizes of `r min(sapply(goByID, length))` to `r max(sapply(goByID, length))` genes.
    - GO gene sets were restricted to those with 3 or more steps back to the ontology root terms.

## Chromosomal enrichment

It was noted previously that a large proprtion of DE genes were located on the same chromosome as the mutation.
It was therefore posited that the compensatory genetic responses triggered by a mutation may originate from genes nearby the disrupted gene.
If this is true, genes involved in similar functional pathways may be located within a close genetic distance.
This would make sense from an evolutionary point of view because it would allow advantageous allelic combinations to remain together due to their low chance for recombination.

To test this idea, the leading edge genes from significantly enriched pathways were tested for enrichment of localisation on chromosome 17, the same chromosome as *psen1*.
To test this idea, enrichment testing was performed t.

### Directional GSEA

The following Gene Set Enrichment Analyses were performed taking directionality into account.

```{r}
gsea_d_chr <- lapply(ranks_d, function(x){
  fgseaMultilevel(chrByID, x, eps = 0) %>%
    as_tibble() %>%
    dplyr::rename(FDR = padj) %>%
    mutate(
      edgeSize = vapply(leadingEdge, length, numeric(1)),
      padj = p.adjust(pval, "bonferroni"),
      DE = padj < 0.05
    ) %>%
    dplyr::arrange(pval)
})
```

```{r}
gsea_d_chr$EOfAD %>%
  dplyr::filter(DE) %>%
  mutate(
    Pathway = str_remove(pathway, "HALLMARK_"),
    Pathway = strtrim(Pathway, 45),
    Direction = ifelse(sign(NES) == 1, "Up", "Down"),
    PValue = formatC(pval, digits = 2, format = "e"),
    FDR = formatC(padj, digits = 2, format = "e"),
  ) %>%
  dplyr::select(
    Pathway, Size = size, `Edge size` = edgeSize, PValue, FDR
  ) %>%
  kable(
    align = "l",
    caption = paste(
      "The", nrow(.), "enriched Hallmark pathways for the EOfAD comparison",
      "using directional rankings and a threshold of FDR < 0.05."
    )
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
gsea_d_chr$fAI %>%
  dplyr::filter(DE) %>%
  mutate(
    Pathway = str_remove(pathway, "HALLMARK_"),
    Pathway = strtrim(Pathway, 45),
    Direction = ifelse(sign(NES) == 1, "Up", "Down"),
    PValue = formatC(pval, digits = 2, format = "e"),
    FDR = formatC(padj, digits = 2, format = "e"),
  ) %>%
  dplyr::select(
    Pathway, Size = size, `Edge size` = edgeSize, PValue, FDR
  ) %>%
  kable(
    align = "l",
    caption = paste(
      "The", nrow(.), "enriched Hallmark pathways for the fAI comparison",
      "using directional rankings and a threshold of FDR < 0.05."
    )
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

### Non-directional GSEA

Similarly to the directional Gene Set Enrichment Analyses, testing was performed on the non-directional ranked list.

```{r}
gsea_nd_chr <- lapply(ranks_nd, function(x){
  fgseaMultilevel(chrByID, x, eps = 0, scoreType = "pos") %>%
    as_tibble() %>%
    dplyr::rename(FDR = padj) %>%
    mutate(
      edgeSize = vapply(leadingEdge, length, numeric(1)),
      padj = p.adjust(pval, "bonferroni"),
      DE = padj < 0.05
    ) %>%
    dplyr::arrange(pval)
})
```

```{r}
gsea_nd_chr$EOfAD %>%
  dplyr::filter(DE) %>%
  mutate(
    Pathway = str_remove(pathway, "HALLMARK_"),
    Pathway = strtrim(Pathway, 45),
    Direction = ifelse(sign(NES) == 1, "Up", "Down"),
    PValue = formatC(pval, digits = 2, format = "e"),
    FDR = formatC(padj, digits = 2, format = "e"),
  ) %>%
  dplyr::select(
    Pathway, Size = size, `Edge size` = edgeSize, PValue, FDR
  ) %>%
  kable(
    align = "l",
    caption = paste(
      "The", nrow(.), "enriched Hallmark pathways for the EOfAD comparison",
      "using non-directional rankings and a threshold of FDR < 0.05."
    )
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
gsea_nd_chr$fAI %>%
  dplyr::filter(DE) %>%
  mutate(
    Pathway = str_remove(pathway, "HALLMARK_"),
    Pathway = strtrim(Pathway, 45),
    Direction = ifelse(sign(NES) == 1, "Up", "Down"),
    PValue = formatC(pval, digits = 2, format = "e"),
    FDR = formatC(padj, digits = 2, format = "e"),
  ) %>%
  dplyr::select(
    Pathway, Size = size, `Edge size` = edgeSize, PValue, FDR
  ) %>%
  kable(
    align = "l",
    caption = paste(
      "The", nrow(.), "enriched Hallmark pathways for the fAI comparison",
      "using non-directional rankings and a threshold of FDR < 0.05."
    )
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

## Functional enrichment

It was noted previously that a large proportion of DE genes were located on the same chromosome as the mutation.
It was therefore posited that the compensatory genetic responses triggered by a mutation may originate from nearby the disrupted gene.
If this is true, genes involved in similar functional pathways may be located within a close genetic distance.
This would make sense from an evolutionary point of view because it would allow advantageous allelic combinations to remain together due to their low chance for recombination.

To test this idea, the leading edge genes from significantly enriched pathways were tested for enrichment of localisation on chromosome 17, the same chromosome as *psen1*.

#### Directional

```{r}
edgeGenes_d_chr <- lapply(gsea_d_chr, function(x){
  x %>%
    dplyr::filter(DE) %>%
    with(structure(leadingEdge, names = pathway))
})
# edgeGenes_d_chr <- edgeGenes_d_chr[sapply(edgeGenes_d_chr, length) > 0]
```

##### GSEA

```{r}
map2(ranks_d, edgeGenes_d_chr, function(ranks, edgeGenes){
  lapply(edgeGenes, function(chr){
    ranks <- ranks[chr]
    fgseaMultilevel(goByID, ranks, eps = 0) %>%
      as_tibble() %>%
      dplyr::rename(FDR = padj) %>%
      mutate(
        edgeSize = vapply(leadingEdge, length, numeric(1)),
        padj = p.adjust(pval, "bonferroni"),
        DE = padj < 0.05
      ) %>%
      dplyr::arrange(pval)
  })
})
```

##### goseq

```{r}
pwf <- map2(topTables, edgeGenes_d_chr, function(table, edgeGenes){
  lapply(edgeGenes, function(chr){
    table %>%
      mutate(edge = gene_id %in% chr) %>%
      with(nullp(
        DEgenes = structure(
          as.integer(edge), names = gene_id
        ),
        genome = "danRer11",
        id = "ensGene",
        bias.data = length,
        plot.fit = TRUE
      ))
  })
})
plotPWF(pwf$fAI$`17`)
```

```{r}
goseq <- lapply(pwf, function(genotype){
  lapply(genotype, function(chr){
    goseq(chr, gene2cat = goByGene) %>%
      as_tibble() %>%
      mutate(p.adj = p.adjust(over_represented_pvalue, "fdr"))
  })
})
```

#### Non-directional

```{r}
edgeGenes_nd_chr <- lapply(gsea_nd_chr, function(x){
  if (length(x) > 0) {
    x %>%
      dplyr::filter(DE) %>%
      with(structure(leadingEdge, names = pathway))
  } else {
    NULL
  }
})
edgeGenes_nd_chr <- edgeGenes_nd_chr[sapply(edgeGenes_nd_chr, length) > 0]
```

##### GSEA

```{r}
map2(ranks_nd, edgeGenes_nd_chr, function(ranks, edgeGenes){
  lapply(edgeGenes, function(chr){
    ranks <- ranks[chr]
    fgseaMultilevel(goByID, ranks, eps = 0, scoreType = "pos") %>%
      as_tibble() %>%
      dplyr::rename(FDR = padj) %>%
      mutate(
        edgeSize = vapply(leadingEdge, length, numeric(1)),
        padj = p.adjust(pval, "bonferroni"),
        DE = padj < 0.05
      ) %>%
      dplyr::arrange(pval)
  })
})
```

##### goseq

```{r}
pwf <- map2(topTables, edgeGenes_nd_chr, function(table, edgeGenes){
  lapply(edgeGenes, function(chr){
    table %>%
      mutate(edge = gene_id %in% chr) %>%
      with(nullp(
        DEgenes = structure(
          as.integer(edge), names = gene_id
        ),
        genome = "danRer11",
        id = "ensGene",
        bias.data = length,
        plot.fit = FALSE
      ))
  })
})
plotPWF(pwf$EOfAD$`17`)
```

```{r}
goseq <- lapply(pwf, function(genotype){
  lapply(genotype, function(chr){
    goseq(chr, gene2cat = wkByGene) %>%
      as_tibble() %>%
      mutate(p.adj = p.adjust(over_represented_pvalue, "fdr"))
  })
})
```