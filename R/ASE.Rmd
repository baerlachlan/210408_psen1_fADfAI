---
title: "Allele Specific Expression Analysis"
author: "Lachlan Baer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    fig_width: 8
    fig_height: 6
    fig_align: "center"
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  error = FALSE, 
  fig.align = "center"
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

# Setup 

```{r packages}
library(tidyverse)
library(magrittr)
library(parallel)
library(here)
library(AnnotationHub)
library(purrr)
library(scales)
```

```{r options}
if (interactive()) setwd(here::here())
theme_set(theme_bw())
cores <- detectCores() - 1
```

```{r}
source("~/bioinformatics/lbBioUtils/lbFuncs.R")
```

## EnsDb

```{r}
ah <- AnnotationHub() %>%
  subset(species == "Danio rerio") %>%
  subset(rdataclass == "EnsDb")
ensDb <- ah[["AH83189"]] ## Ens101
genes <- genes(ensDb)
mcols(genes) <- mcols(genes)[
  c("gene_id", "gene_name", "gene_biotype", "entrezid")
]
exons <- exonsBy(ensDb, by = "gene")
```

# Load data

## Metadata

```{r}
metadata <- read_csv(here("files/samples.csv")) %>%
  dplyr::select(-sample) %>%
  dplyr::rename(sample = basename, genotype = Genotype)
print.inf(metadata)
```

## Counts

Heterozygous SNPs detected by `ASEReadCounter` were recorded in a seperate `tsv`
file for each sample. 
These were loaded into R as a list of tibbles containing the unprocessed raw 
data for ASE analysis.

```{r}
files <- list.files(
  "/hpcfs/users/a1647910/210408_psen1_fADfAI_snv/15_aseReadCounts",
  full.names = TRUE
)
samples <- basename(files) %>%
  str_remove(".tsv")
drChrs <- seq(1:25)
```

```{r}
aseCounts <- lapply(files, function(file){
  sample <- basename(file) %>%
    str_remove(".tsv")
  read_tsv(
    file,
    col_types = "cdcccdddddddd"
  ) %>%
    dplyr::filter(contig %in% as.character(drChrs)) %>%
    mutate(
      sample = sample,
      allele = paste0(refAllele, ",", altAllele)
    ) %>%
    left_join(metadata[,c("sample", "genotype")]) %>%
    dplyr::select(
      chromosome = contig, position, allele, refCount, altCount, totalCount, 
      sample, genotype, lowMAPQDepth, lowBaseQDepth, rawDepth, otherBases, 
      improperPairs
    )
}) %>% 
  set_names(samples)
```

The number of genome-wide het-SNP positions as reported by `ASEReadCounter` 
ranged from `r comma(min(sapply(aseCounts, nrow)))` to
`r comma(max(sapply(aseCounts, nrow)))` across all samples.

```{r include=FALSE, eval=FALSE}
# nucCols <- tibble(A = NA, C = NA, G = NA, T = NA) # In case a base is not detected
# perBaseCounts <- lapply(aseCounts, function(x){
#   x %>%
#     mutate(allele = paste0(refAllele, ",", altAllele)) %>%
#     pivot_longer(
#       cols = c("refAllele", "altAllele"),
#       names_to = "variant",
#       values_to = "base"
#     ) %>% 
#     mutate(value = ifelse(variant == "refAllele", refCount, altCount)) %>%
#     dplyr::select(-variant) %>%
#     pivot_wider(names_from = base, values_from = value) %>%
#     add_column(!!!nucCols[!names(nucCols) %in% names(.)]) %>% # Adds column of NA's if no detected base
#     dplyr::select(
#       chromosome = contig, position, allele, A, C, G, T, totalCount, 
#       rawDepth, sample
#     ) %>%
#     left_join(metadata[,c("sample", "genotype")])
# })
# perBaseProps <- lapply(perBaseCounts, function(x){
#   x %>%
#     mutate(across(c(A, C, G, T), ~ ./totalCount))
# })
```

# Quality control

## ASEReadCounter

GATK tool `ASEReadCounter` calculates allele counts at a set of positions
after applying filters specifically tuned for AE analysis of RNA-seq data.
The filters operate on mapping quality, base quality, depth of coverage and
overlapping paired reads.
Each of these filters can be controlled by command-line arguments.
The data in this analysis was generated with the following options:

* `--min-mapping-quality 10`
* `--min-base-quality 20`
* `--count-overlap-reads-handling COUNT_FRAGMENTS_REQUIRE_SAME_BASE`
+ Ths option counts all fragments where the base is consistent when mate pairs
overlap.
* `--min-depth-of-non-filtered-base -1`
+ This argument is disabled, because depth filtering will be performed
manually (see next section).

```{r}
filtProps <- aseCounts %>%
  purrr::reduce(rbind) %>%
  group_by(sample) %>%
  summarise(
    mapQ = sum(lowMAPQDepth) / sum(rawDepth),
    baseQ = sum(lowBaseQDepth) / sum(rawDepth),
    otherBases = sum(otherBases) / sum(rawDepth)
  )
```

With the above settings across all samples, reads filtered due to insufficient 
mapping quality ranged between `r percent(min(filtProps$mapQ), accuracy = 0.01)` 
and `r percent(max(filtProps$mapQ), accuracy = 0.01)`, reads filtered due to
base quality ranged between `r percent(min(filtProps$baseQ), accuracy = 0.01)` 
and `r percent(max(filtProps$baseQ), accuracy = 0.01)`, and reads filtered due
to overlapping mate pairs with inconsistent bases ranged between 
`r percent(min(filtProps$otherBases), accuracy = 0.01)` and 
`r percent(max(filtProps$otherBases), accuracy = 0.01)`.

More information about recommended quality control measures can be found in
[Castel et al. Tools and Best Practices for allelic expression analysis.](https://www.biorxiv.org/content/biorxiv/early/2015/03/05/016097.full.pdf)

## Coverage

Since the variants originate from RNA-seq data, they were filtered based on 
genomic position for those that lie in only exonic regions (Ensembl version 101).
Gene identifiers were also annotated for each position to enable downstream 
analysis of ASE across genes.

```{r}
exonOverlaps <- lapply(aseCounts, function(x){
  indices <- x %>%
    dplyr::select(seqnames = chromosome, start = position) %>%
    mutate(end = start) %>%
    makeGRangesFromDataFrame() %>%
    findOverlaps(exons)
  tibble(
    snpInd = as.data.frame(indices)$queryHits,
    geneInd = as.data.frame(indices)$subjectHits
  )
})
```

```{r}
exonCounts <- lapply(seq_along(aseCounts), function(x){
  aseCounts[[x]][exonOverlaps[[x]]$snpInd,] %>%
    cbind(gene = names(exons[exonOverlaps[[x]]$geneInd])) %>%
    as_tibble() %>%
    rownames_to_column("snpID")
}) %>%
  set_names(samples)
```

After filtering for SNPs in exonic regions, the remaining number of het-SNPs 
ranged from `r comma(min(sapply(exonCounts, nrow)))` to
`r comma(max(sapply(exonCounts, nrow)))` across all samples.

Het-SNPs sites were also filtered based on coverage, as low total counts
will be unsuitable for determining ASE.
Firstly, a quick inspection of coverage distribution.

```{r}
exonCounts %>%
  purrr::reduce(rbind) %>%
  ggplot(aes(totalCount, colour = sample)) +
  stat_ecdf(geom = "step") +
  coord_cartesian(xlim = c(0, 400)) +
  labs(x = "Reads / heat-SNP", y = "Cumulative distribution") +
  theme(legend.position = "none") 
```

```{r}
lapply(exonCounts, function(x){
  n0 <- x %>%
    dplyr::filter(totalCount >= 0) %>%
    nrow()
  n10 <- x %>%
    dplyr::filter(totalCount >= 10) %>%
    nrow()
  n20 <- x %>%
    dplyr::filter(totalCount >= 20) %>%
    nrow()
  n30 <- x %>%
    dplyr::filter(totalCount >= 30) %>%
    nrow()
  n60 <- x %>%
    dplyr::filter(totalCount >= 60) %>%
    nrow()
  sample <- unique(x$sample)
  tibble(
    bin = c("\u2265 0", "\u2265 10", "\u2265 20", "\u2265 30", "\u2265 60"),
    n = c(n0, n10, n20, n30, n60),
    sample = sample
  )
}) %>%
  purrr::reduce(rbind) %>%
  ggplot(aes(bin, n, fill = bin)) +
  geom_boxplot() +
  labs(x = "Reads / het-SNP", y = "het-SNPs per sample") +
  theme(legend.position = "none")
```

```{r}
exonCounts <- lapply(exonCounts, function(x){
  dplyr::filter(x, totalCount >= 10)
})
```

With a cut-off of at least 10 counts per het-SNP position, 
`r comma(min(sapply(exonCounts, nrow)))` to
`r comma(max(sapply(exonCounts, nrow)))` het-SNPs remained across all samples.

## Reference mapping bias

An important aspect to consider in AE analysis is the potential for mapping bias.
For RNA-seq data mapped to a reference genome, reads that carry an alternate 
allele at positions of variation have at least one mismatch, and therefore a 
lower probability of aligning correctly than reads containing the reference 
allele.
To estimate this effect we can calculate the genome-wide reference ratio,
which will indicate a reference mapping bias if above 0.5.
This calculated ratio may be more suitable as the null in downstream statistical 
testing.

```{r}
aseRatios <- lapply(exonCounts, function(x){
  x %>%
    dplyr::filter(totalCount != 0) %>%
    mutate(
      refRatio = refCount / totalCount,
      altRatio = altCount / totalCount
    ) %>%
    dplyr::select(
      chromosome, position, allele, refRatio, altRatio, totalCount,
      sample
    )
})
```

```{r}
aseRatios %>%
  purrr::reduce(rbind) %>%
  left_join(metadata[,c("sample", "genotype")]) %>%
  dplyr::arrange(genotype, sample) %>%
  mutate(sample = factor(sample, levels = unique(sample))) %>%
  ggplot(aes(sample, refRatio, fill = genotype)) +
  geom_boxplot() +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 2) +
  geom_hline(yintercept = 0.5, linetype = "dashed", colour = "black") +
  labs(x = "Sample", y = "Reference allele ratio") +
  scale_fill_discrete(name = "Genotype") +
  scale_y_continuous(breaks = seq(0, 1, 0.2)) +
  theme(axis.text.x = element_text(angle = -90, vjust = 0.5))
```

```{r}
refBias <- aseRatios %>%
  purrr::reduce(rbind) %>%
  group_by(sample) %>%
  summarise(mean = mean(refRatio), median = median(refRatio))
altBias <- aseRatios %>%
  purrr::reduce(rbind) %>%
  group_by(sample) %>%
  summarise(mean = mean(altRatio), median = median(altRatio))
```

A reference mapping bias is evident across all samples.
Mean reference ratios ranged between `r round(min(refBias$mean), 3)` and 
`r round(max(refBias$mean), 3)`.
Median reference ratios ranged between `r round(min(refBias$median), 3)`
and `r round(max(refBias$median), 3)`.

# Static ASE

Static ASE is ...

## GeneiASE export

```{r}
staticCounts <- lapply(exonCounts, function(x){
  x %>%
    left_join(altBias[,c("sample", "mean")]) %>%
    dplyr::select(
      gene, snpID, altCount, refCount, betabinom.p = mean
    )
})
lapply(seq_along(staticCounts), function(x){
  path <- paste0(
    "/hpcfs/users/a1647910/210408_psen1_fADfAI_snv/16_geneiASE/input/",
    names(staticCounts[x]),
    ".static.tsv"
  )
  if (!file.exists(path)) {
    if (!dir.exists(dirname(path))) {
      dir.create(dirname(path), recursive = TRUE)
    }
    write_tsv(staticCounts[[x]], path)
  }
})
```

## GeneiASE import