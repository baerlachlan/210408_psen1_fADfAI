---
title: "eQTL exploration"
author: "Lachlan Baer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    fig_width: 8
    fig_height: 6
    fig_align: "center"
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  error = FALSE, 
  fig.align = "center"
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

# Setup 

```{r packages}
library(tidyverse)
library(magrittr)
library(parallel)
library(here)
library(AnnotationHub)
library(purrr)
```

```{r options}
if (interactive()) setwd(here::here())
theme_set(theme_bw())
cores <- detectCores() - 1
```

## Annotation

```{r}
ah <- AnnotationHub() %>%
  subset(species == "Danio rerio") %>%
  subset(rdataclass == "EnsDb")
ensDb <- ah[["AH83189"]] ## Ens101
genes <- genes(ensDb)
mcols(genes) <- mcols(genes)[
  c("gene_id", "gene_name", "gene_biotype", "entrezid")
]
exons <- exonsBy(ensDb, by = "gene")
```

```{r}
drChrs <- seq(1:25)
nucCols <- tibble(A = NA, C = NA, G = NA, T = NA)
```

# Load data

## Metadata

```{r}
metadata <- read_csv(here("files/samples.csv")) %>%
  dplyr::select(-sample) %>%
  dplyr::rename(sample = basename, genotype = Genotype)
```

## Counts

```{r}
files <- list.files(
  "/hpcfs/users/a1647910/210408_psen1_fADfAI_snv/15_aseReadCounts",
  full.names = TRUE
)
samples <- basename(files) %>%
  str_remove(".tsv")
aseCounts_raw <- lapply(files, function(file){
  sample <- basename(file) %>%
    str_remove(".tsv")
  read_tsv(
    file,
    col_types = "cdcccdddddddd"
  ) %>%
    mutate(sample = sample) %>%
    dplyr::filter(contig %in% as.character(drChrs))
}) %>% 
  set_names(samples)
```

```{r}
aseCounts <- lapply(aseCounts_raw, function(x){
  x %>%
    mutate(allele = paste0(refAllele, ",", altAllele)) %>%
    pivot_longer(
      cols = c("refAllele", "altAllele"),
      names_to = "variant",
      values_to = "base"
    ) %>% 
    mutate(value = ifelse(variant == "refAllele", refCount, altCount)) %>%
    dplyr::select(-variant) %>%
    pivot_wider(names_from = base, values_from = value) %>%
    add_column(!!!nucCols[!names(nucCols) %in% names(.)]) %>%
    dplyr::select(
      chromosome = contig, position, allele, A, C, G, T, totalCount, 
      rawDepth, sample
    ) %>%
    left_join(metadata[,c("sample", "genotype")])
})
aseProps <- lapply(aseCounts, function(x){
  x %>%
    mutate(across(c(A, C, G, T), ~ ./totalCount))
})
```

# Data exploration

## Coverage

```{r}
aseCounts %>%
  purrr::reduce(rbind) %>%
  ggplot(aes(totalCount, colour = sample)) +
  stat_ecdf(geom = "step") +
  coord_cartesian(xlim = c(0, 400))
```

```{r}
lapply(aseCounts, function(x){
  x %>%
    mutate(
      bin = ifelse(totalCount >= 0, 0, NA),
      bin = ifelse(totalCount >= 10, 10, bin),
      bin = ifelse(totalCount >= 20, 20, bin),
      bin = ifelse(totalCount >= 30, 30, bin),
      bin = ifelse(totalCount >= 60, 60, bin)
    ) %>%
    group_by(bin) %>%
    summarise(n = n(), sample = unique(sample))
})
  
```

# Quality control

## ASEReadCounter

GATK tool `ASEReadCounter` calculates allele conts at a set of positions
after applying filters specifically tuned for AE analysis of RNA-seq data.
The filters operate on mapping quality, base quality, depth of coverage, 
overlapping paired reads and deletions overlapping the position.
They are controlled by the command-line arguments:

* `--min-mapping-quality`
* `--min-base-quality`
* `--min-depth-of-non-filtered-base`
* `--count-overlap-reads-handling`

These filters address a number of the quality control measures suggested in
[Castel et al. Tools and Best Practices for allelic expression analysis.](https://www.biorxiv.org/content/biorxiv/early/2015/03/05/016097.full.pdf)

## Reference mapping bias

An important aspect of AE analysis is the potential effects of mapping bias.
For RNA-seq data mapped to a reference genome, reads that carry an alternate 
allele at positions of variation have at least one mismatch, and therefore have 
a lower probability of aligning correctly that reads containing the reference 
allele.
To estimate this effect we can calculate the genome-wide reference ratio,
which will indicate a reference mapping bias if above 0.5.
This calculated ratio may be a more suitable null in downstream statistical 
testing, improving results.

```{r}
refaltRatios <- lapply(aseCounts_raw, function(x){
  x %>%
    dplyr::filter(totalCount != 0) %>%
    mutate(
      allele = paste0(refAllele, ",", altAllele),
      refRatio = refCount / totalCount,
      altRatio = altCount / totalCount
    ) %>%
    dplyr::select(
      chromosome = contig, position, allele, refRatio, altRatio, totalCount, sample
    )
}) %>%
  purrr::reduce(rbind) 
refaltRatios %>%
  left_join(metadata[,c("sample", "genotype")]) %>%
  dplyr::arrange(genotype, sample) %>%
  mutate(sample = factor(sample, levels = unique(sample))) %>%
  ggplot(aes(sample, refRatio, fill = genotype)) +
  geom_boxplot() +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 2) +
  labs(x = "Sample", y = "Reference allele ratio") +
  scale_fill_discrete(name = "Genotype") +
  theme(axis.text.x = element_text(angle = -90, vjust = 0.5))
```

```{r}
refRatMean <- refaltRatios %>%
  group_by(sample) %>%
  summarise(mean = mean(refRatio))
refRatMedian <- refaltRatios %>%
  group_by(sample) %>%
  summarise(median = median(refRatio))
```

A reference mapping bias is evident across all samples.
Mean reference ratios ranged between `r round(min(refRatMean$mean), 3)` and 
`r round(max(refRatMean$mean), 3)`.
Median reference ratios ranged between `r round(min(refRatMedian$median), 3)`
and `r round(max(refRatMedian$median), 3)`.

# Gene variants

```{r}
geneSym <- "psen1"
```

```{r}
geneHets <- lapply(aseCounts, function(x){
  geneId <- genes %>%
    subset(seqnames %in% drChrs) %>%
    subset(gene_name == geneSym) %>%
    .$gene_id
  eoi <- exons[[geneId]]
  chr <- seqnames(eoi) %>%
    unique() %>%
    as.character() %>%
    as.numeric()
  ranges <- ranges(eoi) %>% 
    as.data.frame() %>% 
    pmap(function(start, end, ...){seq(start, end)}) %>%
    unlist() %>%
    unique()
  x %>% 
    dplyr::filter(
      chromosome == chr,
      position %in% ranges
    )
})
```

```{r}
hetsPerSample <- lapply(seq_along(geneHets), function(x){
  tibble(sample = names(geneHets)[x], het_positions = nrow(geneHets[[x]]))
}) %>%
  purrr::reduce(rbind) %>%
  left_join(metadata) %>%
  dplyr::arrange(genotype, sample)
```

