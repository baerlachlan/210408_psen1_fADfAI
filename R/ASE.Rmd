---
title: "eQTL exploration"
author: "Lachlan Baer"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    fig_width: 8
    fig_height: 6
    fig_align: "center"
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  error = FALSE, 
  fig.align = "center"
)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

# Setup 

```{r packages}
library(tidyverse)
library(magrittr)
library(parallel)
library(here)
library(AnnotationHub)
library(purrr)
library(scales)
```

```{r options}
if (interactive()) setwd(here::here())
theme_set(theme_bw())
cores <- detectCores() - 1
```

```{r}
source("~/bioinformatics/lbBioUtils/lbFuncs.R")
```

## Annotation

```{r}
ah <- AnnotationHub() %>%
  subset(species == "Danio rerio") %>%
  subset(rdataclass == "EnsDb")
ensDb <- ah[["AH83189"]] ## Ens101
genes <- genes(ensDb)
mcols(genes) <- mcols(genes)[
  c("gene_id", "gene_name", "gene_biotype", "entrezid")
]
exons <- exonsBy(ensDb, by = "gene")
```

```{r}
drChrs <- seq(1:25)
nucCols <- tibble(A = NA, C = NA, G = NA, T = NA)
```

# Load data

## Metadata

```{r}
metadata <- read_csv(here("files/samples.csv")) %>%
  dplyr::select(-sample) %>%
  dplyr::rename(sample = basename, genotype = Genotype)
```

## Counts

```{r}
files <- list.files(
  "/hpcfs/users/a1647910/210408_psen1_fADfAI_snv/15_aseReadCounts",
  full.names = TRUE
)
samples <- basename(files) %>%
  str_remove(".tsv")
```

```{r}
aseCounts_raw <- lapply(files, function(file){
  sample <- basename(file) %>%
    str_remove(".tsv")
  read_tsv(
    file,
    col_types = "cdcccdddddddd"
  ) %>%
    mutate(sample = sample) %>%
    dplyr::filter(contig %in% as.character(drChrs))
}) %>% 
  set_names(samples)
```

```{r}
aseCounts <- lapply(aseCounts_raw, function(x){
  x %>%
    mutate(allele = paste0(refAllele, ",", altAllele)) %>%
    dplyr::select(
      chromosome = contig, position, allele, refCount, altCount, totalCount, sample
    )
})
```

```{r}
aseRatios <- lapply(aseCounts_raw, function(x){
  x %>%
    dplyr::filter(totalCount != 0) %>%
    mutate(
      allele = paste0(refAllele, ",", altAllele),
      refRatio = refCount / totalCount,
      altRatio = altCount / totalCount
    ) %>%
    dplyr::select(
      chromosome = contig, position, allele, refRatio, altRatio, totalCount, sample
    )
})
```

```{r}
perBaseCounts <- lapply(aseCounts_raw, function(x){
  x %>%
    mutate(allele = paste0(refAllele, ",", altAllele)) %>%
    pivot_longer(
      cols = c("refAllele", "altAllele"),
      names_to = "variant",
      values_to = "base"
    ) %>% 
    mutate(value = ifelse(variant == "refAllele", refCount, altCount)) %>%
    dplyr::select(-variant) %>%
    pivot_wider(names_from = base, values_from = value) %>%
    add_column(!!!nucCols[!names(nucCols) %in% names(.)]) %>%
    dplyr::select(
      chromosome = contig, position, allele, A, C, G, T, totalCount, 
      rawDepth, sample
    ) %>%
    left_join(metadata[,c("sample", "genotype")])
})
perBaseProps <- lapply(perBaseCounts, function(x){
  x %>%
    mutate(across(c(A, C, G, T), ~ ./totalCount))
})
```

# Quality control

## ASEReadCounter

GATK tool `ASEReadCounter` calculates allele counts at a set of positions
after applying filters specifically tuned for AE analysis of RNA-seq data.
The filters operate on mapping quality, base quality, depth of coverage and
overlapping paired reads.
Each of these filters can be controlled by command-line arguments.
The data in this analysis was generated with the following options:

* `--min-mapping-quality 10`
* `--min-base-quality 20`
* `--count-overlap-reads-handling COUNT_FRAGMENTS_REQUIRE_SAME_BASE`
  + Ths option counts all fragments where the base is consistent when mate pairs
  overlap.
* `--min-depth-of-non-filtered-base -1`
  + This argument is disabled, because depth filtering will be performed
  manually (see next section).

```{r}
filtProps <- aseCounts_raw %>%
  purrr::reduce(rbind) %>%
  group_by(sample) %>%
  summarise(
    mapQ = sum(lowMAPQDepth) / sum(rawDepth),
    baseQ = sum(lowBaseQDepth) / sum(rawDepth),
    otherBases = sum(otherBases) / sum(rawDepth)
    )
```

With the above settings across all samples, reads filtered due to insufficient 
mapping quality ranged between `r percent(min(filtProps$mapQ), accuracy = 0.01)` 
and `r percent(max(filtProps$mapQ), accuracy = 0.01)`, reads filtered due to
base quality ranged between `r percent(min(filtProps$baseQ), accuracy = 0.01)` 
and `r percent(max(filtProps$baseQ), accuracy = 0.01)`, and reads filtered due
to overlapping mate pairs with inconsistent bases ranged between 
`r percent(min(filtProps$otherBases), accuracy = 0.01)` and 
`r percent(max(filtProps$otherBases), accuracy = 0.01)`.

More information about recommended quality control measures can be found in
[Castel et al. Tools and Best Practices for allelic expression analysis.](https://www.biorxiv.org/content/biorxiv/early/2015/03/05/016097.full.pdf)

## Coverage

Heterozygous SNP sites should also be filtered based on coverage, as low counts
will be uninformative ...

```{r}
aseCounts %>%
  purrr::reduce(rbind) %>%
  ggplot(aes(totalCount, colour = sample)) +
  stat_ecdf(geom = "step") +
  coord_cartesian(xlim = c(0, 400)) +
  labs(x = "Reads / heat-SNP", y = "Cumulative distribution") +
  theme(legend.position = "none") 
```

```{r}
lapply(aseCounts, function(x){
  n0 <- x %>%
    dplyr::filter(totalCount > 0) %>%
    nrow()
  n10 <- x %>%
    dplyr::filter(totalCount > 10) %>%
    nrow()
  n20 <- x %>%
    dplyr::filter(totalCount > 20) %>%
    nrow()
  n30 <- x %>%
    dplyr::filter(totalCount > 30) %>%
    nrow()
  n60 <- x %>%
    dplyr::filter(totalCount > 60) %>%
    nrow()
  sample <- unique(x$sample)
  tibble(
    bin = c(">0", ">10", ">20", ">30", ">60"),
    n = c(n0, n10, n20, n30, n60),
    sample = sample
  )
}) %>%
  purrr::reduce(rbind) %>%
  ggplot(aes(bin, n, fill = bin)) +
  geom_boxplot() +
  labs(x = "Reads / het-SNP", y = "het-SNPs per sample") +
  theme(legend.position = "none")
```

## Reference mapping bias

An important aspect to consider in AE analysis is the potential for mapping bias.
For RNA-seq data mapped to a reference genome, reads that carry an alternate 
allele at positions of variation have at least one mismatch, and therefore a 
lower probability of aligning correctly than reads containing the reference 
allele.
To estimate this effect we can calculate the genome-wide reference ratio,
which will indicate a reference mapping bias if above 0.5.
This calculated ratio may be more suitable as the null in downstream statistical 
testing.

```{r}
aseRatios %>%
  purrr::reduce(rbind) %>%
  left_join(metadata[,c("sample", "genotype")]) %>%
  dplyr::arrange(genotype, sample) %>%
  mutate(sample = factor(sample, levels = unique(sample))) %>%
  ggplot(aes(sample, refRatio, fill = genotype)) +
  geom_boxplot() +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 2) +
  labs(x = "Sample", y = "Reference allele ratio") +
  scale_fill_discrete(name = "Genotype") +
  theme(axis.text.x = element_text(angle = -90, vjust = 0.5))
```

```{r}
refBias <- aseRatios %>%
  purrr::reduce(rbind) %>%
  group_by(sample) %>%
  summarise(mean = mean(refRatio), median = median(refRatio))
```

A reference mapping bias is evident across all samples.
Mean reference ratios ranged between `r round(min(refBias$mean), 3)` and 
`r round(max(refBias$mean), 3)`.
Median reference ratios ranged between `r round(min(refBias$median), 3)`
and `r round(max(refBias$median), 3)`.

# Gene variants

```{r}
geneSym <- "psen1"
```

```{r}
geneHets <- lapply(aseCounts, function(x){
  geneId <- genes %>%
    subset(seqnames %in% drChrs) %>%
    subset(gene_name == geneSym) %>%
    .$gene_id
  eoi <- exons[[geneId]]
  chr <- seqnames(eoi) %>%
    unique() %>%
    as.character() %>%
    as.numeric()
  ranges <- ranges(eoi) %>% 
    as.data.frame() %>% 
    pmap(function(start, end, ...){seq(start, end)}) %>%
    unlist() %>%
    unique()
  x %>% 
    dplyr::filter(
      chromosome == chr,
      position %in% ranges
    )
})
```

```{r}
hetsPerSample <- lapply(seq_along(geneHets), function(x){
  tibble(sample = names(geneHets)[x], het_positions = nrow(geneHets[[x]]))
}) %>%
  purrr::reduce(rbind) %>%
  left_join(metadata) %>%
  dplyr::arrange(genotype, sample)
```

